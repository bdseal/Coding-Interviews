/*
数组A包含了0到n的所有整数，但其中缺失了一个。
对于这个问题，我们设定限制，使得一次操作无法取得数组number里某个整数的完整内容。
唯一的可用操作是询问数组中第i个元素的二进制的第j位(最低位为第0位)，
该操作的时间复杂度为常数，请设计算法，在O(n)的时间内找到这个数。
 
给定一个数组number，即所有剩下的数按从小到大排列的二进制各位的值，
如A[0][1]表示剩下的第二个数二进制从低到高的第二位。同时给定一个int n，意义如题。请返回缺失的数。
 
测试样例：[[0],[0,1]]
返回：1
*/
/*
题目说明：题目用数组A的一行元素表示一个整数，即A[0]～A[n-1]分别代表n个整数。
记A[m]表示整数a,则第m行的第x列表示a的二进制表示时从低到高的第x位。
样例中A[0]为[0]，即第1位为0，表示整数0；A[1]=[0,1],即第1位为0，第2位为1，表示整数2，因此缺失了整数1。
样例中如果有其他整数，如A[5],则应该为[1,0,1]，依次类推。
*/
 
/*
思路：只需要考察数组中每个数的最低位与序号的奇偶是否相同。即i % 2==numbers[i][0]?True:false
1. 由于数组中的数是0~n剩余数按照从小到大进行排列的，因此在缺失数之前，数组行标与数是相等的，即行标i = x，
2. 此时行标i % 2的值与数组中numbers[i][0]是相等的，即i为奇数，numbers[i][0]为1；为偶数时，numbers[i][0]为0.
第一个 i % 2与numbers[i][0]不相等处即为缺失数。
要注意缺失数为n即最大值的情况。要单独return n；
*/
class Finder {
public:
    int findMissing(vector<vector<int> > numbers, int n) {
        for(int i=0;i<n;i++)
        {
            if(i%2!=numbers[i][0]) return i;
        }
        return n;
    }
};